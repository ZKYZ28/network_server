Index: app/src/main/java/org/helmo/murmurG6/controller/ServerController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.controller;\r\n\r\nimport org.helmo.murmurG6.models.User;\r\nimport org.helmo.murmurG6.models.UserLibrary;\r\nimport org.helmo.murmurG6.models.exceptions.UserAlreadyRegisteredException;\r\nimport org.helmo.murmurG6.repository.UserRepository;\r\nimport org.helmo.murmurG6.repository.exceptions.SaveUserCollectionException;\r\nimport org.helmo.murmurG6.utils.UltraImportantClass;\r\n\r\nimport javax.net.ServerSocketFactory;\r\nimport javax.net.ssl.SSLServerSocket;\r\nimport javax.net.ssl.SSLServerSocketFactory;\r\nimport javax.net.ssl.SSLSocket;\r\nimport java.io.IOException;\r\nimport java.net.InetAddress;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.net.UnknownHostException;\r\nimport java.util.*;\r\n\r\n/**\r\n * La classe ServerController représente le contrôleur principal de l'application serveur.\r\n * Cette classe gère la connexion des clients et communique avec la classe ClientRunnable pour gérer la communication avec les clients.\r\n */\r\npublic class ServerController implements AutoCloseable {\r\n    private final Set<ClientRunnable> clientList = Collections.synchronizedSet(new HashSet<>());\r\n    private final SSLServerSocket serverSocket;\r\n    private final UserRepository storage;\r\n    private final UserLibrary userLibrary;\r\n\r\n    /**\r\n     * Le constructeur de la classe ServerController permet de créer un nouveau serveur en spécifiant un numéro de port et un storage d'utilisateurs.\r\n     *\r\n     * @param port Le numéro de port sur lequel le serveur écoutera les connexions entrantes.\r\n     * @param repo Le storage d'utilisateurs qui sera utilisé pour enregistrer et lire les informations d'utilisateur.\r\n     * @throws IOException En cas d'échec de la création du socket serveur.\r\n     */\r\n    public ServerController(int port, UserRepository repo) throws IOException {\r\n        SSLServerSocketFactory sslServerSocketFactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r\n        this.serverSocket = (SSLServerSocket) sslServerSocketFactory.createServerSocket(port);\r\n        //this.serverSocket = new ServerSocket(port);\r\n        this.storage = repo;\r\n        this.userLibrary = repo.load(); //remplissage de tous les users inscrits dans la usercollection\r\n\r\n        UltraImportantClass.welcome();\r\n        System.out.println(\"****************************************************************\");\r\n        System.out.println(\"********      SERVER ONLINE ! IP : \" + getIp() + \"        *********\");\r\n        System.out.println(\"****************************************************************\");\r\n    }\r\n\r\n\r\n    public void start() throws IOException {\r\n        TaskScheduler executor = Executor.getInstance();\r\n        executor.setServer(this);\r\n        new Thread(executor).start();\r\n\r\n        while (!this.serverSocket.isClosed()) {\r\n            SSLSocket client = (SSLSocket) serverSocket.accept();\r\n            //Socket client = serverSocket.accept();\r\n            System.out.println(\"Quelqu'un s'est connecté!\");\r\n            ClientRunnable runnable = new ClientRunnable(client);\r\n            clientList.add(runnable);\r\n            new Thread(runnable).start();\r\n        }\r\n    }\r\n\r\n    public void broadcastToAllClientsExceptMe(ClientRunnable me, String message) {\r\n        System.out.printf(\"[broadcastAll] Message envoyé : %s\\n\", message);\r\n        for (ClientRunnable c : clientList) {\r\n            if (c != me) {\r\n                c.sendMessage(\"MSGS admin@192.168.0.19 \" + message);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /*public void broadcastOther(ClientRunnable me, String message) {\r\n        Set<ClientRunnable> needToSend = tellWhoRecevedMessage(me, message);\r\n        for (ClientRunnable c : needToSend) {\r\n            c.sendMessage(\"MSGS \" + c.getUser().getLogin() + \"@server1.domain.guru \" + message);\r\n        }\r\n    }\r\n\r\n    public Set<ClientRunnable> tellWhoRecevedMessage(ClientRunnable me, String message) {\r\n        Set<ClientRunnable> needToSend = Collections.synchronizedSet(new HashSet<>());\r\n        for (ClientRunnable c : clientList) {\r\n            if (c != me) {\r\n                if (c.getUser().chekcIfFollowUser(me.getUser().getLogin())) {\r\n                    needToSend.add(c);\r\n                }\r\n                Set<String> trendsInMessage = detectTrends(message);\r\n                if(trendsInMessage.size() != 0) {\r\n                    for (FollowInformation follow : me.getUser().getFollowedTrends()) {\r\n                        if (c.getUser().chekcIfFollowTrend(follow) && trendsInMessage.contains(follow.getInformationFollow())) {\r\n                            needToSend.add(c);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return needToSend;\r\n    }\r\n\r\n    private Set<String> detectTrends(String message) {\r\n        Set<String> trends = new HashSet<>();\r\n        int index = 0;\r\n        while (index < message.length()) {\r\n            index = message.indexOf(\"#\", index);\r\n            if (index == -1) {\r\n                break;\r\n            }\r\n            index++;\r\n            int debutMot = index;\r\n            int finMot = message.indexOf(\" \", index);\r\n            if (finMot == -1) {\r\n                finMot = message.length();\r\n            }\r\n            String mot = message.substring(debutMot, finMot);\r\n            trends.add(mot);\r\n        }\r\n        return trends;\r\n    }*/\r\n\r\n    public void castMsg(ClientRunnable senderClient, String message) {\r\n        System.out.printf(\"Message envoyé : %s\\n\", message);\r\n        //Envoyer le message à tous ceux qui follow senderClient\r\n\r\n\r\n        for (ClientRunnable c : clientList) {\r\n            if (c != senderClient) {\r\n                c.sendMessage(\"MSGS admin@192.168.0.19 \" + message);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    public void saveUsers() throws SaveUserCollectionException {\r\n        storage.save(this.userLibrary);\r\n    }\r\n\r\n    public UserLibrary getUserCollection() {\r\n        return userLibrary;\r\n    }\r\n\r\n    public String getIp() {\r\n        try {\r\n            return InetAddress.getLocalHost().getHostAddress();\r\n        } catch (UnknownHostException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void close() {\r\n        try {\r\n            this.serverSocket.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/controller/ServerController.java b/app/src/main/java/org/helmo/murmurG6/controller/ServerController.java
--- a/app/src/main/java/org/helmo/murmurG6/controller/ServerController.java	(revision 74cac887f1b2689dd2d739b3f49445dd0c8f62e3)
+++ b/app/src/main/java/org/helmo/murmurG6/controller/ServerController.java	(date 1676566515003)
@@ -134,8 +134,6 @@
     }
 
 
-
-
     public void saveUsers() throws SaveUserCollectionException {
         storage.save(this.userLibrary);
     }
Index: app/src/main/resources/storage/user.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[\r\n  {\r\n    \"login\": \"antho\",\r\n    \"bcryptDto\": {\r\n      \"rounds\": 14,\r\n      \"salt\": \"D1vZrgYQvRX5DqerJbwmAe\",\r\n      \"hash\": \"SA.HraPqaf6VgQd2YczEy9Ehp70FAVu\"\r\n    },\r\n    \"followedUsers\": [\r\n      \"antho@star.godswila.guru\"\r\n    ],\r\n    \"followedTrends\": []\r\n  }\r\n]
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/resources/storage/user.json b/app/src/main/resources/storage/user.json
--- a/app/src/main/resources/storage/user.json	(revision 74cac887f1b2689dd2d739b3f49445dd0c8f62e3)
+++ b/app/src/main/resources/storage/user.json	(date 1676567004930)
@@ -1,13 +1,14 @@
 [
   {
-    "login": "antho",
+    "login": "franchi",
     "bcryptDto": {
       "rounds": 14,
-      "salt": "D1vZrgYQvRX5DqerJbwmAe",
-      "hash": "SA.HraPqaf6VgQd2YczEy9Ehp70FAVu"
+      "salt": "I1BDKYtttTtqeWFWufi4J.",
+      "hash": "HukUKqujI9X2SOQxYSnQSCftOWp4D1e"
     },
     "followedUsers": [
-      "antho@star.godswila.guru"
+      "antho@g6server1.godswila.guru",
+      "testing@g6server1.godswila.guru"
     ],
     "followedTrends": []
   }
Index: app/src/main/java/org/helmo/murmurG6/infrastructure/UserJsonStorage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.infrastructure;\r\n\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.reflect.TypeToken;\r\nimport org.helmo.murmurG6.infrastructure.dto.Mapper;\r\nimport org.helmo.murmurG6.infrastructure.dto.UserDto;\r\nimport org.helmo.murmurG6.models.UserLibrary;\r\nimport org.helmo.murmurG6.repository.UserRepository;\r\nimport org.helmo.murmurG6.repository.exceptions.ReadUserCollectionException;\r\nimport org.helmo.murmurG6.repository.exceptions.SaveUserCollectionException;\r\nimport java.io.*;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\nimport java.nio.file.StandardOpenOption;\r\nimport java.util.*;\r\n\r\n/**\r\n * Cette classe implémente l'interface {@link UserRepository} et permet de sauvegarder et de lire des collections d'utilisateurs sous forme de fichier JSON.\r\n * La classe utilise la bibliothèque Google Gson pour effectuer les opérations de conversion entre les objets Java et les données JSON.\r\n * Les fichiers sont sauvegardés dans un emplacement spécifié par la classe {@link JsonConfig}.\r\n *\r\n * @version 1.0\r\n * @since 11 février 2023\r\n */\r\npublic class UserJsonStorage implements UserRepository {\r\n    private final Path FILE_PATH = Paths.get(JsonConfig.SAVE_DIR, \"/user.json\");\r\n    private final Gson gson = new Gson();\r\n\r\n\r\n    @Override\r\n    public void save(UserLibrary uc) throws SaveUserCollectionException {\r\n        createFile(FILE_PATH);\r\n\r\n        try (BufferedWriter bufferedWriter = Files.newBufferedWriter(FILE_PATH, StandardCharsets.UTF_8, StandardOpenOption.CREATE)) {\r\n            gson.toJson(Mapper.userDtoListFromUsers(new ArrayList<>(uc.values())), new TypeToken<ArrayList<UserDto>>() {\r\n            }.getType(), bufferedWriter);\r\n        } catch (IOException e) {\r\n            throw new SaveUserCollectionException(\"Impossible de sauvegarder la liste d'utilisateur!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     * Cette méthode lit une collection d'utilisateurs enregistrée en tant que fichier JSON à l'emplacement spécifié.\r\n     * Si le fichier n'existe pas, il sera créé.\r\n     */\r\n    @Override\r\n    public UserLibrary load() throws ReadUserCollectionException {\r\n        createFile(FILE_PATH);\r\n\r\n        try (BufferedReader reader = Files.newBufferedReader(FILE_PATH, StandardCharsets.UTF_8)) {\r\n            Iterable<UserDto> resultDto = gson.fromJson(reader, new TypeToken<ArrayList<UserDto>>() {\r\n            }.getType());\r\n            return UserLibrary.of(Mapper.userListFromDto(resultDto));\r\n        } catch (IOException e) {\r\n            throw new ReadUserCollectionException(\"Impossible de charger la liste d'utilisateurs!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Crée un fichier à l'emplacement spécifié. Si le répertoire parent de l'emplacement n'existe pas, il sera créé.\r\n     *\r\n     * @param path l'emplacement du fichier à créer\r\n     */\r\n    private void createFile(Path path) {\r\n        try {\r\n            Files.createDirectories(path.getParent());\r\n            if (!Files.exists(path)) {\r\n                Files.createFile(path);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/infrastructure/UserJsonStorage.java b/app/src/main/java/org/helmo/murmurG6/infrastructure/UserJsonStorage.java
--- a/app/src/main/java/org/helmo/murmurG6/infrastructure/UserJsonStorage.java	(revision 74cac887f1b2689dd2d739b3f49445dd0c8f62e3)
+++ b/app/src/main/java/org/helmo/murmurG6/infrastructure/UserJsonStorage.java	(date 1676566849733)
@@ -33,9 +33,8 @@
     public void save(UserLibrary uc) throws SaveUserCollectionException {
         createFile(FILE_PATH);
 
-        try (BufferedWriter bufferedWriter = Files.newBufferedWriter(FILE_PATH, StandardCharsets.UTF_8, StandardOpenOption.CREATE)) {
-            gson.toJson(Mapper.userDtoListFromUsers(new ArrayList<>(uc.values())), new TypeToken<ArrayList<UserDto>>() {
-            }.getType(), bufferedWriter);
+        try (BufferedWriter bufferedWriter = Files.newBufferedWriter(FILE_PATH, StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {
+            gson.toJson(Mapper.userDtoListFromUsers(uc.values()), new TypeToken<ArrayList<UserDto>>(){}.getType(), bufferedWriter);
         } catch (IOException e) {
             throw new SaveUserCollectionException("Impossible de sauvegarder la liste d'utilisateur!");
         }
