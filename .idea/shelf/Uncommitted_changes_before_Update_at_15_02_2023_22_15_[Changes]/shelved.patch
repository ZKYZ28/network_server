Index: app/src/main/java/org/helmo/murmurG6/models/BCrypt.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.models;\r\n\r\nimport java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\n\r\n/**\r\n * <p>La classe BcryptHash représente un hachage Bcrypt d'un mot de passe.</p><br>\r\n *\r\n * <p>Elle contient les informations sur le nombre de tours utilisé pour le hachage (rounds),\r\n * la valeur de sel utilisée (salt), et le hachage résultant (hash).</p><br>\r\n *\r\n * <p>Cette classe fournit également des méthodes pour décomposer un hachage Bcrypt en ses composants,\r\n * calculer le hachage d'une chaîne de caractères aléatoire et du hachage BCrypt,\r\n * et convertir un tableau d'octets en une chaîne de caractères hexadécimale.</p>\r\n *\r\n * @since 11 février 2023\r\n * @version 1.0\r\n */\r\npublic class BCrypt {\r\n\r\n    private final int rounds;\r\n    private final String salt;\r\n    private final String hash;\r\n\r\n    public BCrypt(int rounds, String salt, String hash) {\r\n        this.rounds = rounds;\r\n        this.salt = salt;\r\n        this.hash = hash;\r\n    }\r\n\r\n    public int getRounds() {\r\n        return rounds;\r\n    }\r\n\r\n    public String getSalt() {\r\n        return salt;\r\n    }\r\n\r\n    public String getHash() {\r\n        return hash;\r\n    }\r\n\r\n\r\n    /**\r\n     * Décompose un hachage Bcrypt en ses composants.\r\n     *\r\n     * @param hashed le hachage Bcrypt à décomposer, qui doit avoir le format suivant : $2a$RR$SALT$HASH\r\n     * où RR représente le nombre de tours de l'algorithme de hachage, SALT est la valeur de sel utilisée\r\n     * lors du hachage et HASH est le hachage résultant.\r\n     *\r\n     * @return un objet BcryptHash contenant les informations décomposées : le nombre de tours (rounds), la valeur de sel (salt)\r\n     * et le hachage (hash).\r\n     */\r\n    public static BCrypt decomposeHash(String hashed) {\r\n        int rounds = Integer.parseInt(hashed.substring(4, 6));\r\n        String salt = hashed.substring(7, 29);\r\n        String hash = hashed.substring(29);\r\n        return new BCrypt(rounds, salt, hash);\r\n    }\r\n\r\n    /**\r\n     * La méthode calculateChallenge calcule le hachage de la chaîne de caractères aléatoires et du hachage BCrypt en utilisant l'algorithme SHA3-256.\r\n     * Le hachage BCrypt inclut le nombre de tours et le sel associé au mot de passe.\r\n     * Le résultat de la fonction de hachage est retourné sous forme hexadécimale.\r\n     *\r\n     * @param random La chaîne de caractères aléatoires reçue lors de la connexion avec le serveur.\r\n     * @return Le hachage calculé sous forme hexadécimale.\r\n     */\r\n    public String calculateChallenge(String random) {\r\n        try {\r\n            MessageDigest md = MessageDigest.getInstance(\"SHA3-256\");\r\n            byte[] unHashedChallengeBytes = (random + this.toString()).getBytes();\r\n            byte[] hashedBytes = md.digest(unHashedChallengeBytes);\r\n            return bytesToHex(hashedBytes);\r\n        } catch (NoSuchAlgorithmException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Cette méthode permet de convertir un tableau d'octets en une chaîne de caractères hexadécimale.\r\n     *\r\n     * @param bytes Le tableau d'octets à convertir.\r\n     * @return La chaîne de caractères hexadécimale représentant le tableau d'octets.\r\n     */\r\n    private String bytesToHex(byte[] bytes) {\r\n        StringBuilder sb = new StringBuilder(bytes.length * 2);\r\n        for (byte b : bytes) {\r\n            sb.append(String.format(\"%02x\", b & 0xff));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"$2b$\"+ this.rounds + \"$\" + this.salt + this.hash;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/models/BCrypt.java b/app/src/main/java/org/helmo/murmurG6/models/BCrypt.java
--- a/app/src/main/java/org/helmo/murmurG6/models/BCrypt.java	(revision 7e2432234cc25a47d49370aefa9ba54a700153cf)
+++ b/app/src/main/java/org/helmo/murmurG6/models/BCrypt.java	(date 1676495726002)
@@ -2,6 +2,7 @@
 
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.regex.Pattern;
 
 /**
  * <p>La classe BcryptHash représente un hachage Bcrypt d'un mot de passe.</p><br>
@@ -28,54 +29,33 @@
         this.hash = hash;
     }
 
-    public int getRounds() {
-        return rounds;
-    }
-
-    public String getSalt() {
-        return salt;
-    }
+    public static BCrypt of(String hashed) {
+        if (!Pattern.matches(Protocol.RX_BCRYPT_HASH, hashed)) {
+            throw new IllegalArgumentException("Le hash bcrypt fourni n'est pas au format attendu. Veuillez vérifier que le hash est une chaîne valide conforme au format bcrypt.");
+        }
 
-    public String getHash() {
-        return hash;
-    }
-
-
-    /**
-     * Décompose un hachage Bcrypt en ses composants.
-     *
-     * @param hashed le hachage Bcrypt à décomposer, qui doit avoir le format suivant : $2a$RR$SALT$HASH
-     * où RR représente le nombre de tours de l'algorithme de hachage, SALT est la valeur de sel utilisée
-     * lors du hachage et HASH est le hachage résultant.
-     *
-     * @return un objet BcryptHash contenant les informations décomposées : le nombre de tours (rounds), la valeur de sel (salt)
-     * et le hachage (hash).
-     */
-    public static BCrypt decomposeHash(String hashed) {
         int rounds = Integer.parseInt(hashed.substring(4, 6));
         String salt = hashed.substring(7, 29);
         String hash = hashed.substring(29);
+
         return new BCrypt(rounds, salt, hash);
     }
 
-    /**
-     * La méthode calculateChallenge calcule le hachage de la chaîne de caractères aléatoires et du hachage BCrypt en utilisant l'algorithme SHA3-256.
-     * Le hachage BCrypt inclut le nombre de tours et le sel associé au mot de passe.
-     * Le résultat de la fonction de hachage est retourné sous forme hexadécimale.
-     *
-     * @param random La chaîne de caractères aléatoires reçue lors de la connexion avec le serveur.
-     * @return Le hachage calculé sous forme hexadécimale.
-     */
-    public String calculateChallenge(String random) {
+
+    public String generateChallenge(String random) {
+        MessageDigest md;
         try {
-            MessageDigest md = MessageDigest.getInstance("SHA3-256");
-            byte[] unHashedChallengeBytes = (random + this.toString()).getBytes();
-            byte[] hashedBytes = md.digest(unHashedChallengeBytes);
-            return bytesToHex(hashedBytes);
-        } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException(e);
-        }
+            md = MessageDigest.getInstance("SHA3-256");
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException("Impossible de générer un challenge. L'algorithme de hachage SHA3-256 n'est pas disponible.", e);
+        }
+
+        byte[] unHashedChallengeBytes = (random + this).getBytes();
+        byte[] hashedBytes = md.digest(unHashedChallengeBytes);
+
+        return bytesToHex(hashedBytes);
     }
+
 
 
     /**
@@ -85,13 +65,25 @@
      * @return La chaîne de caractères hexadécimale représentant le tableau d'octets.
      */
     private String bytesToHex(byte[] bytes) {
-        StringBuilder sb = new StringBuilder(bytes.length * 2);
+        StringBuilder sb = new StringBuilder();
         for (byte b : bytes) {
-            sb.append(String.format("%02x", b & 0xff));
+            sb.append(String.format("%02x", b));
         }
         return sb.toString();
     }
 
+    public int getRounds() {
+        return rounds;
+    }
+
+    public String getSalt() {
+        return salt;
+    }
+
+    public String getHash() {
+        return hash;
+    }
+
     @Override
     public String toString() {
         return "$2b$"+ this.rounds + "$" + this.salt + this.hash;
Index: app/src/main/java/org/helmo/murmurG6/models/Protocol.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.models;\r\n\r\nimport org.helmo.murmurG6.repository.IProtocol;\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class Protocol implements IProtocol {\r\n\r\n    /*\r\n     * ACSII Characters\r\n     * [\\x21-\\x2f] : correspond à la plage des codes hexadécimaux 0x21 à 0x2f, qui comprend les symboles suivants :\r\n     * ! \" # $ % & ' ( ) * + , - . /\r\n     *\r\n     * [\\x3a-\\x40] : correspond à la plage des codes hexadécimaux 0x3a à 0x40, qui comprend les symboles suivants :\r\n     * : ; < = > ? @\r\n     *\r\n     * [\\x5B-\\x60] : correspond à la plage des codes hexadécimaux 0x5B à 0x60, qui comprend les symboles suivants :\r\n     * [ \\ ] ^ _ `\r\n     *\r\n     */\r\n\r\n    private static final String RX_DIGIT = \"[0-9]\";\r\n    private static final String RX_LETTER = \"[a-zA-Z]\";\r\n    private static final String RX_LETTER_DIGIT = RX_LETTER + \"|\" + RX_DIGIT;\r\n    private static final String RX_SYMBOL = \"[\\\\x21-\\\\x2f]|[\\\\x3a-\\\\x40]|[\\\\x5B-\\\\x60]\";\r\n    private static final String RX_ROUND = \"(\" + RX_DIGIT + \"{2})\";\r\n    private static final String RX_PASSCHAR = \"[\\\\x22-\\\\xff]\";\r\n    private static final String RX_VISIBLE_CHARACTER = \"[\\\\x20-\\\\xff]\";\r\n    private static final String RX_INFORMATION_MESSAGE = \"((\" + RX_VISIBLE_CHARACTER + \"){0,200})\";\r\n    private static final String RX_RANDOM = \"((\" + RX_LETTER_DIGIT + \"|\" + RX_SYMBOL + \"){22})\";\r\n    private static final String RX_BCRYPT_SALT = \"((\" + RX_LETTER_DIGIT + \"|\" + RX_SYMBOL + \"){22})\";\r\n    private final static String RX_ESP = \"\\\\s\";\r\n    private static final String RX_DOMAIN = \"((\" + RX_LETTER_DIGIT + \"|\\\\.){5,200})\";\r\n    private static final String RX_USERNAME = \"((\" + RX_LETTER_DIGIT + \"){5,20})\";\r\n    private static final String RX_USER_DOMAIN = \"(\" + RX_USERNAME + \"@\" + RX_DOMAIN + \")\";\r\n    private static final String RX_MESSAGE = \"((\" + RX_VISIBLE_CHARACTER + \"){1,250})\";\r\n    private static final String RX_SHA3_EX = \"((\" + RX_LETTER_DIGIT+ \"){30,200})\";\r\n\r\n    /*PARTS*/\r\n    private static final String RX_CRLF = \"(\\\\x0d\\\\x0a){0,1}\";\r\n    private static final String RX_SALT_SIZE = \"([0-9]{2})\";\r\n    private static final String RX_BCRYPT_HASH = \"(\\\\$2b\\\\$\\\\d{2}\\\\$(\" + RX_LETTER_DIGIT + \"|\" + RX_SYMBOL + \"){1,70})\";\r\n    private static final String TAG = \"#[a-zA-Z0-9]{5,20}\";\r\n    private static final String TAG_DOMAIN = \"(\" + TAG + \"@\" + RX_DOMAIN + \")\";\r\n\r\n    private static final String TAG_DOMAIN_OR_RX_USER_DOMAIN = \"(\" + RX_USER_DOMAIN + \"|\" + TAG_DOMAIN + \")\";\r\n\r\n\r\n    /*FULL*/\r\n    private final static String CONNECT = \"CONNECT\" + RX_ESP + RX_USERNAME + RX_CRLF;\r\n    private final static String REGISTER = \"REGISTER\" + RX_ESP + RX_USERNAME + RX_ESP + RX_SALT_SIZE + RX_ESP + RX_BCRYPT_HASH + RX_CRLF;\r\n    private final static String FOLLOW = \"FOLLOW\" + RX_ESP + TAG_DOMAIN_OR_RX_USER_DOMAIN + RX_CRLF;\r\n    private final static String CONFIRM = \"CONFIRM\" + RX_ESP + RX_SHA3_EX + RX_CRLF;\r\n    private final static String DISCONNECT = \"DISCONNECT\" + RX_CRLF;\r\n    private final static String MSG = \"MSG\" + RX_ESP + RX_MESSAGE;\r\n    private final String[] TYPE_MESSAGE = {CONNECT, REGISTER, FOLLOW, CONFIRM, DISCONNECT, MSG};\r\n\r\n    /**\r\n     * Méthode qui permet de créer une Objet Message sur base d'une string\r\n     * @param msg String qui est le message reçu depuis le Client\r\n     * @return Message(typeMessage, matcher, msg)\r\n     */\r\n    @Override\r\n    public Task analyseMessage(String msg){\r\n        for (int i = 0; i < TYPE_MESSAGE.length; i++) {\r\n            if(Pattern.matches(TYPE_MESSAGE[i], msg)){\r\n                return new Task(identifyTypeMessage(i), createMatcher(msg, i), msg);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Méthode qui permet d'identifier le type d'un message\r\n     * @param i i qui est l'index dans le tableau des différents types de message\r\n     * @return MessageType qui est le type de message\r\n     */\r\n    private TaskType identifyTypeMessage(int i){\r\n        switch (i){\r\n            case 0:\r\n                return TaskType.CONNECT;\r\n            case 1:\r\n                return TaskType.REGISTER;\r\n            case 2:\r\n                return TaskType.FOLLOW;\r\n            case 3:\r\n                return TaskType.CONFIRM;\r\n            case 4:\r\n                return TaskType.DISCONNECT;\r\n            case 5:\r\n                return TaskType.MSG;\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Méthode qui permet de créer un Matcher qui reprend les différentes parties d'un message\r\n     * @param msg String qui est le message reçu depuis le client\r\n     * @param i int qui est l'index dans le tableau des différents types de message\r\n     * @return Matcher qui comporte les différentes parties d'un message\r\n     */\r\n    private Matcher createMatcher(String msg, int i){\r\n        Pattern pattern = Pattern.compile(TYPE_MESSAGE[i]);\r\n        Matcher matcher = pattern.matcher(msg);\r\n        matcher.matches();\r\n        return matcher;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/models/Protocol.java b/app/src/main/java/org/helmo/murmurG6/models/Protocol.java
--- a/app/src/main/java/org/helmo/murmurG6/models/Protocol.java	(revision 7e2432234cc25a47d49370aefa9ba54a700153cf)
+++ b/app/src/main/java/org/helmo/murmurG6/models/Protocol.java	(date 1676495736731)
@@ -40,7 +40,7 @@
     /*PARTS*/
     private static final String RX_CRLF = "(\\x0d\\x0a){0,1}";
     private static final String RX_SALT_SIZE = "([0-9]{2})";
-    private static final String RX_BCRYPT_HASH = "(\\$2b\\$\\d{2}\\$(" + RX_LETTER_DIGIT + "|" + RX_SYMBOL + "){1,70})";
+    public static final String RX_BCRYPT_HASH = "(\\$2b\\$\\d{2}\\$(" + RX_LETTER_DIGIT + "|" + RX_SYMBOL + "){1,70})";
     private static final String TAG = "#[a-zA-Z0-9]{5,20}";
     private static final String TAG_DOMAIN = "(" + TAG + "@" + RX_DOMAIN + ")";
 
