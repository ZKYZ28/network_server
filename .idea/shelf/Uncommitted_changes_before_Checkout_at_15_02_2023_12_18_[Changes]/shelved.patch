Index: app/src/main/resources/storage/user.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[\r\n  {\r\n    \"login\": \"monsieurDeVleeg\",\r\n    \"bcryptDto\": {\r\n      \"rounds\": 14,\r\n      \"salt\": \"hbfQB24W2w9ZIjB6OKKF0.\",\r\n      \"hash\": \"/fiiam7eMLONf/6a6oGnJ/kQhAr1eYq\"\r\n    },\r\n    \"followedUsers\": [],\r\n    \"followedTrends\": []\r\n  },\r\n  {\r\n    \"login\": \"test1\",\r\n    \"bcryptDto\": {\r\n      \"rounds\": 14,\r\n      \"salt\": \"8It8N2ARUVOfl9rmYC5Nju\",\r\n      \"hash\": \"jX1unhjd56qOh9nK7Yadt/LG6Hz5y0O\"\r\n    },\r\n    \"followedUsers\": [],\r\n    \"followedTrends\": []\r\n  }\r\n]
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/resources/storage/user.json b/app/src/main/resources/storage/user.json
--- a/app/src/main/resources/storage/user.json	(revision 8b5f92cac09e374c468a18480daf87b01257c36b)
+++ b/app/src/main/resources/storage/user.json	(date 1676457644440)
@@ -1,22 +1,1 @@
-[
-  {
-    "login": "monsieurDeVleeg",
-    "bcryptDto": {
-      "rounds": 14,
-      "salt": "hbfQB24W2w9ZIjB6OKKF0.",
-      "hash": "/fiiam7eMLONf/6a6oGnJ/kQhAr1eYq"
-    },
-    "followedUsers": [],
-    "followedTrends": []
-  },
-  {
-    "login": "test1",
-    "bcryptDto": {
-      "rounds": 14,
-      "salt": "8It8N2ARUVOfl9rmYC5Nju",
-      "hash": "jX1unhjd56qOh9nK7Yadt/LG6Hz5y0O"
-    },
-    "followedUsers": [],
-    "followedTrends": []
-  }
-]
\ No newline at end of file
+[{"login":"giuseppe","bcryptDto":{"rounds":14,"salt":"YEMJfEI53sI.qpTGf4jE.u","hash":"FQiWQFU2ZlNGTM3Jrft09kNkGXyRIOK"},"followedUsers":[],"followedTrends":[]},{"login":"monsieurDeVleeg","bcryptDto":{"rounds":14,"salt":"zTEDHMh9cRcGpNz4ChsSP.","hash":"ZJbO/W7lLIzU0siMf6J6FkN3B7PQEGq"},"followedUsers":[],"followedTrends":[]},{"login":"francis","bcryptDto":{"rounds":14,"salt":"4sUZLBZRTJoowChx1PMoPe","hash":"xVwdLL4t0kIV67IySQ5V/.mcRpaaQYm"},"followedUsers":[],"followedTrends":[]}]
\ No newline at end of file
Index: app/src/main/java/org/helmo/murmurG6/system/ServerController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.system;\r\n\r\nimport org.helmo.murmurG6.models.FollowInformation;\r\nimport org.helmo.murmurG6.models.User;\r\nimport org.helmo.murmurG6.models.UserCollection;\r\nimport org.helmo.murmurG6.models.exceptions.UserAlreadyRegisteredException;\r\nimport org.helmo.murmurG6.repository.IUserCollectionRepository;\r\nimport org.helmo.murmurG6.repository.exceptions.SaveUserCollectionException;\r\nimport org.helmo.murmurG6.utils.UltraImportantClass;\r\n\r\nimport javax.net.ssl.*;\r\nimport java.io.IOException;\r\nimport java.net.InetAddress;\r\nimport java.net.UnknownHostException;\r\nimport java.util.*;\r\n\r\n/**\r\n * La classe ServerController représente le contrôleur principal de l'application serveur.\r\n * Cette classe gère la connexion des clients et communique avec la classe ClientRunnable pour gérer la communication avec les clients.\r\n */\r\npublic class ServerController implements AutoCloseable {\r\n    private final List<ClientRunnable> clientList = Collections.synchronizedList(new ArrayList<>());\r\n    private final SSLServerSocket  serverSocket;\r\n    private final IUserCollectionRepository repo;\r\n    private final UserCollection userCollection = new UserCollection();\r\n    private Executor executor;\r\n    private final int port;\r\n\r\n    /**\r\n     * Le constructeur de la classe ServerController permet de créer un nouveau serveur en spécifiant un numéro de port et un storage d'utilisateurs.\r\n     *\r\n     * @param port Le numéro de port sur lequel le serveur écoutera les connexions entrantes.\r\n     * @param repo Le storage d'utilisateurs qui sera utilisé pour enregistrer et lire les informations d'utilisateur.\r\n     * @throws IOException En cas d'échec de la création du socket serveur.\r\n     */\r\n    public ServerController(int port, IUserCollectionRepository repo) throws IOException {\r\n        SSLServerSocketFactory ssf = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r\n        this.serverSocket = (SSLServerSocket) ssf.createServerSocket(port);\r\n        this.repo = repo;\r\n        this.port = port;\r\n        this.userCollection.setRegisteredUsers(repo.read()); //remplissage de tous les users inscrits dans la usercollection\r\n        UltraImportantClass.welcome();\r\n        System.out.println(\"****************************************************************\");\r\n        System.out.println(\"********      SERVER ONLINE ! IP : \" +getIp()+\"        *********\");\r\n        System.out.println(\"****************************************************************\");\r\n    }\r\n\r\n    /**\r\n     * La méthode start() démarre le serveur en initialisant l'objet Executor et en écoutant les connexions des clients.\r\n     * Lorsqu'un client se connecte, une nouvelle instance de ClientRunnable est créée pour gérer la communication avec celui-ci.\r\n     *\r\n     * @throws IOException en cas d'erreur lors de l'initialisation du ServerSocket\r\n     */\r\n    public void start() throws IOException {\r\n        this.executor = new Executor(this);\r\n        new Thread(executor).start();\r\n        while(true) {\r\n            SSLSocket client = (SSLSocket) serverSocket.accept();\r\n            ClientRunnable runnable = new ClientRunnable(client,this);\r\n            clientList.add(runnable);\r\n            new Thread(runnable).start();\r\n        }\r\n    }\r\n\r\n    public void broadcastToAllClientsExceptMe(ClientRunnable me, String message) {\r\n        System.out.printf(\"[broadcastAll] Message envoyé : %s\\n\", message);\r\n        for(ClientRunnable c : clientList) {\r\n            if (c != me) {\r\n                c.sendMessage(\"MSGS admin@192.168.0.19 \" + message);\r\n            }\r\n        }\r\n    }\r\n\r\n    public Set<ClientRunnable> tellWhoRecevedMessage(ClientRunnable me) {\r\n        Set<ClientRunnable> needToSend = Collections.synchronizedSet(new HashSet<>());\r\n        for (ClientRunnable c : clientList) {\r\n            if (c != me) {\r\n                if (c.getUser().chekcIfFollowUser(me.getUser().getLogin())) {\r\n                    needToSend.add(c);\r\n                }\r\n\r\n                for (FollowInformation follow : me.getUser().getFollowedTrends()) {\r\n                    if (c.getUser().chekcIfFollowTrend(follow)) {\r\n                        needToSend.add(c);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return needToSend;\r\n    }\r\n\r\n    public void broadcastOther(ClientRunnable me, String message) {\r\n        Set<ClientRunnable> needToSend = tellWhoRecevedMessage(me);\r\n        for (ClientRunnable c : needToSend) {\r\n            c.sendMessage(\"MSGS \" + c.getUser().getLogin() + \" : \" + message);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Enregistre un utilisateur dans la liste d'inscription de User du server.\r\n     * @param user L'utilisateur à inscrire sur le server\r\n     * @throws RegistrationImpossibleException\r\n     */\r\n    public void registerUser(User user) throws RegistrationImpossibleException {\r\n        try{\r\n            userCollection.registerUser(user);\r\n            repo.save(userCollection.getRegisteredUsers().values()); //On sauvegarde le contenu de la userCollection à la fermeture du server\r\n        } catch (UserAlreadyRegisteredException | SaveUserCollectionException e) {\r\n            throw new RegistrationImpossibleException(\"Inscription impossible!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enregistre un follow qu'il soit sur un User ou sur un Trend\r\n     * @throws RegistrationImpossibleException\r\n     */\r\n    public void followUserOrTrend() throws RegistrationImpossibleException {\r\n        try{\r\n            repo.save(userCollection.getRegisteredUsers().values());\r\n        } catch (SaveUserCollectionException e) {\r\n            throw new RegistrationImpossibleException(\"Follow impossible!\");\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne la liste des inscrit sur le server\r\n     * @return un objet UserCollection\r\n     */\r\n    public UserCollection getUserCollection() {\r\n        return userCollection;\r\n    }\r\n\r\n    /**\r\n     * Recupere l'addresse IP du server\r\n     * @return L'addresse IP en chaine de carctere\r\n     */\r\n    public String getIp() {\r\n        try {\r\n            return InetAddress.getLocalHost().getHostAddress();\r\n        } catch (UnknownHostException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recupere le port du server\r\n     * @return le port du sertver\r\n     */\r\n    public int getPort() {\r\n        return this.port;\r\n    }\r\n\r\n    /**\r\n     * Recupere l'executor du server\r\n     * @return un objet Executor\r\n     */\r\n    public Executor getExecutor() {\r\n        return executor;\r\n    }\r\n\r\n\r\n    /**\r\n     * Le close sert il a quelque chose ici ? car le server tourne à l'infini et se termine à la fin du programme\r\n     */\r\n    @Override\r\n    public void close() {\r\n        try {\r\n            this.serverSocket.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/system/ServerController.java b/app/src/main/java/org/helmo/murmurG6/system/ServerController.java
--- a/app/src/main/java/org/helmo/murmurG6/system/ServerController.java	(revision 8b5f92cac09e374c468a18480daf87b01257c36b)
+++ b/app/src/main/java/org/helmo/murmurG6/system/ServerController.java	(date 1676458498059)
@@ -7,7 +7,6 @@
 import org.helmo.murmurG6.repository.IUserCollectionRepository;
 import org.helmo.murmurG6.repository.exceptions.SaveUserCollectionException;
 import org.helmo.murmurG6.utils.UltraImportantClass;
-
 import javax.net.ssl.*;
 import java.io.IOException;
 import java.net.InetAddress;
Index: app/src/main/java/org/helmo/murmurG6/system/ClientRunnable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.system;\r\n\r\nimport org.helmo.murmurG6.models.Task;\r\nimport org.helmo.murmurG6.models.Protocol;\r\nimport org.helmo.murmurG6.models.User;\r\nimport org.helmo.murmurG6.utils.RandomSaltGenerator;\r\n\r\nimport javax.net.ssl.SSLContext;\r\nimport javax.net.ssl.SSLSocket;\r\nimport javax.net.ssl.SSLSocketFactory;\r\nimport java.io.*;\r\nimport java.net.Socket;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\npublic class ClientRunnable implements Runnable {\r\n    private BufferedReader in;\r\n    private PrintWriter out;\r\n    private boolean isConnected = false;\r\n    private final ServerController server;\r\n    private User user;\r\n    private Executor executor;\r\n\r\n    private String random22 = \"\";\r\n\r\n    private final Protocol protocol = new Protocol();\r\n\r\n    public ClientRunnable(Socket client, ServerController server) {\r\n        this.server =  server;\r\n        this.executor = server.getExecutor();\r\n\r\n        try {\r\n            in = new BufferedReader(new InputStreamReader(client.getInputStream(), StandardCharsets.UTF_8));\r\n            out = new PrintWriter(new OutputStreamWriter(client.getOutputStream(), StandardCharsets.UTF_8), true);\r\n            isConnected = true;\r\n\r\n        } catch(IOException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void run() {\r\n        try {\r\n            random22 = sayHello();                                      //Envoi du message Hello au client + récupération du random de 22 caractères aléatoires\r\n            String login =\"\";                                           //Le loggin du client\r\n            String ligne = in.readLine();                               //Le server attend que le client ecrive quelque chose\r\n            while(isConnected && ligne != null && !ligne.isEmpty()) {\r\n                System.out.printf(\"Ligne reçue : %s\\r\\n\", ligne);\r\n                Task task = protocol.analyseMessage(ligne); //Création d'une tache sur base de la ligne recue\r\n                if(task != null){\r\n                    task.setClient(this);      //Asignation du ClientRunnable à la tache (utile pour l'executor)\r\n                    executor.addTask(task);     //Ajout de la tache dans la file de taches de l'executor\r\n                }else{\r\n                    sendMessage(\"-ERR pas bien\");\r\n                }\r\n                ligne = in.readLine();    //Le thread mis à disposition du client attend la prochaine ligne\r\n            }\r\n        } catch(IOException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * La méthode sendMessage permet d'envoyer un message au murmur.client associé à cet objet ClientRunnable.\r\n     *\r\n     * @param message Le message à envoyer au murmur.client.\r\n     */\r\n    public void sendMessage(String message) {\r\n        if (isConnected) {\r\n            out.println(message);\r\n            out.flush();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Envoi le message \"Hello\" + une chaine de 22 caractères aléatoire\r\n     * @return la chaine de caractère aléatoire\r\n     */\r\n    private String sayHello() {\r\n        String random22 = RandomSaltGenerator.generateSalt();\r\n        sendMessage(\"HELLO \" + server.getIp() + \" \" + random22);\r\n        return random22;\r\n    }\r\n\r\n    public User getUser(){\r\n        return this.user;\r\n    }\r\n\r\n    public void setUser(User u) {\r\n        this.user = u;\r\n    }\r\n\r\n    public String getRandom22(){\r\n        return random22;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/system/ClientRunnable.java b/app/src/main/java/org/helmo/murmurG6/system/ClientRunnable.java
--- a/app/src/main/java/org/helmo/murmurG6/system/ClientRunnable.java	(revision 8b5f92cac09e374c468a18480daf87b01257c36b)
+++ b/app/src/main/java/org/helmo/murmurG6/system/ClientRunnable.java	(date 1676459202957)
@@ -4,10 +4,6 @@
 import org.helmo.murmurG6.models.Protocol;
 import org.helmo.murmurG6.models.User;
 import org.helmo.murmurG6.utils.RandomSaltGenerator;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
 import java.io.*;
 import java.net.Socket;
 import java.nio.charset.StandardCharsets;
@@ -18,10 +14,8 @@
     private boolean isConnected = false;
     private final ServerController server;
     private User user;
-    private Executor executor;
-
+    private final Executor executor;
     private String random22 = "";
-
     private final Protocol protocol = new Protocol();
 
     public ClientRunnable(Socket client, ServerController server) {
@@ -32,7 +26,6 @@
             in = new BufferedReader(new InputStreamReader(client.getInputStream(), StandardCharsets.UTF_8));
             out = new PrintWriter(new OutputStreamWriter(client.getOutputStream(), StandardCharsets.UTF_8), true);
             isConnected = true;
-
         } catch(IOException ex) {
             ex.printStackTrace();
         }
@@ -41,15 +34,14 @@
     public void run() {
         try {
             random22 = sayHello();                                      //Envoi du message Hello au client + récupération du random de 22 caractères aléatoires
-            String login ="";                                           //Le loggin du client
             String ligne = in.readLine();                               //Le server attend que le client ecrive quelque chose
-            while(isConnected && ligne != null && !ligne.isEmpty()) {
+            while(isConnected && ligne != null && !ligne.isBlank()) {
                 System.out.printf("Ligne reçue : %s\r\n", ligne);
                 Task task = protocol.analyseMessage(ligne); //Création d'une tache sur base de la ligne recue
                 if(task != null){
                     task.setClient(this);      //Asignation du ClientRunnable à la tache (utile pour l'executor)
                     executor.addTask(task);     //Ajout de la tache dans la file de taches de l'executor
-                }else{
+                } else {
                     sendMessage("-ERR pas bien");
                 }
                 ligne = in.readLine();    //Le thread mis à disposition du client attend la prochaine ligne
Index: app/src/main/java/org/helmo/murmurG6/utils/BcryptHash.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.utils;\r\n\r\npublic class BcryptHash {\r\n\r\n    private int rounds;\r\n    private String salt;\r\n    private String hash;\r\n\r\n    public int getRounds() {\r\n        return rounds;\r\n    }\r\n\r\n    public void setRounds(int rounds) {\r\n        this.rounds = rounds;\r\n    }\r\n\r\n    public String getSalt() {\r\n        return salt;\r\n    }\r\n\r\n    public void setSalt(String salt) {\r\n        this.salt = salt;\r\n    }\r\n\r\n    public String getHash() {\r\n        return hash;\r\n    }\r\n\r\n    public void setHash(String hash) {\r\n        this.hash = hash;\r\n    }\r\n\r\n    public static BcryptHash decomposeHash(String hash) {\r\n        BcryptHash parts = new BcryptHash();\r\n        parts.setRounds(Integer.parseInt(hash.substring(4, 6)));\r\n        parts.setSalt(hash.substring(7, 29));\r\n        parts.setHash(hash.substring(29));\r\n        return parts;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        BcryptHash parts = BcryptHash.decomposeHash(\"$2b$14$azertyuiopmlkjhgfdsqwxMotDePasseHashé\");\r\n        System.out.println(parts.salt);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/utils/BcryptHash.java b/app/src/main/java/org/helmo/murmurG6/utils/BcryptHash.java
--- a/app/src/main/java/org/helmo/murmurG6/utils/BcryptHash.java	(revision 8b5f92cac09e374c468a18480daf87b01257c36b)
+++ b/app/src/main/java/org/helmo/murmurG6/utils/BcryptHash.java	(date 1676458498032)
@@ -37,9 +37,4 @@
         parts.setHash(hash.substring(29));
         return parts;
     }
-
-    public static void main(String[] args) {
-        BcryptHash parts = BcryptHash.decomposeHash("$2b$14$azertyuiopmlkjhgfdsqwxMotDePasseHashé");
-        System.out.println(parts.salt);
-    }
 }
Index: app/src/main/java/org/helmo/murmurG6/system/Executor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.system;\r\n\r\nimport org.helmo.murmurG6.models.*;\r\n\r\nimport java.util.concurrent.*;\r\nimport java.util.regex.Matcher;\r\n\r\npublic class Executor implements Runnable, AutoCloseable {\r\n\r\n    private final ExecutorService executorService; //ExecutorService avec un seul thread pour exécuter les tâches de la file d'attente.\r\n    private final BlockingQueue<Task> taskQueue; //File d'attente BlockingQueue appelée taskQueue pour stocker les tâches à exécuter.\r\n    private final ServerController server;\r\n    private final UserCollection collection;\r\n\r\n    public Executor (ServerController server) {\r\n        this.taskQueue = new LinkedBlockingQueue<>();\r\n        this.executorService = Executors.newSingleThreadExecutor();\r\n        this.server = server;\r\n        this.collection = server.getUserCollection();\r\n    }\r\n\r\n    /**\r\n     * Permet d'ajouter des tâches à la file d'attente\r\n     *\r\n     * @param task La tâche a ajouter à la file d'attente\r\n     */\r\n    public void addTask(Task task) {\r\n        taskQueue.add(task);\r\n    }\r\n\r\n    /**\r\n     * Fait tourner l'executor sur un thread\r\n     */\r\n    @Override\r\n    public void run() {\r\n        executorService.submit(() -> {\r\n            while (true) {\r\n                try {\r\n                    //L'executor bloque ici jusqu'à ce qu'une nouvelle tache arrvie\r\n                    Task task = taskQueue.take(); //Consomation des tâches de la file d'attente en appelant la méthode take de BlockingQueue, ce qui bloquera le thread jusqu'à ce qu'une tâche soit disponible dans la file d'attente.\r\n                    executeTask(task);\r\n                } catch (InterruptedException e) {\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Execute la tache passée en paramètre selon son type\r\n     * @param task la tache à exécuter par l'éxécutor\r\n     */\r\n    public void executeTask(Task task) {\r\n\r\n        ClientRunnable client = task.getClient(); //On récupère le client à qui on fait la tache\r\n        Matcher params = task.getMatcher();   //On récupère le matcher de la tache à éxécuter\r\n        User user;\r\n\r\n        switch (task.getType()) {\r\n            case REGISTER:\r\n                user = new User(params.group(1), BCrypt.decomposeHash(params.group(4)));\r\n                client.sendMessage(register(user, client));\r\n                break;\r\n\r\n            case CONNECT:\r\n                user = collection.getUserFromLogin(params.group(1));\r\n                client.setUser(user);\r\n                String login = params.group(1);\r\n                client.sendMessage(connect(login));\r\n                break;\r\n\r\n            case CONFIRM:\r\n                user = client.getUser();\r\n                String received = params.group(1);\r\n                String expected = user.getBcrypt().calculateChallenge(client.getRandom22());\r\n                client.sendMessage(confirm(received, expected));\r\n                break;\r\n\r\n            case MSG:\r\n                server.broadcastOther(client, params.group(1));\r\n                break;\r\n            case FOLLOW:\r\n                follow(params, client.getUser());\r\n                break;\r\n            default:\r\n                client.sendMessage(\"-ERR\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Méthode qui permet d'enregistrer un follow dans le user et d'appeller la méthode pour le stocker dans le Json\r\n     * @param user L'User qui follow\r\n     */\r\n    private void follow(Matcher params, User user)  {\r\n        try {\r\n            if(Protocol.isFollowUser(params.group(1))){\r\n                user.followUser(new FollowInformation(params.group(3), params.group(5)));\r\n            }else{\r\n                user.followTrend(new FollowInformation(params.group(8), params.group(9)));\r\n            }\r\n            server.followUserOrTrend();\r\n        } catch (RegistrationImpossibleException e) {\r\n            //TODO : renvoyer l'erreur\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne le message à envoyer au client lorsque celui veut se connecter\r\n     * @param login le loggin de l'utilisateur qui veut se connecter\r\n     * @return le message PARAM oubien -ERR\r\n     */\r\n    private String connect(String login) {\r\n        if (collection.isRegistered(login)) {\r\n            User user = collection.getUserFromLogin(login);\r\n            return \"PARAM \" + user.getBcryptRound() + \" \" + user.getBcryptSalt();\r\n        } else {\r\n            return \"-ERR\";\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Retourne la confirmation ou non de la connexion du client\r\n     * @param clientChallenge le challenge calculé par le client\r\n     * @param userChallenge le challenge calculé par le server\r\n     * @return le message \"+OK\" si le challenge-client correspond au challenge-server. \"-ERR\" sinon\r\n     */\r\n    private String confirm(String clientChallenge, String userChallenge){\r\n        return clientChallenge.equals(userChallenge) ? \"+OK\" : \"-ERR\";\r\n    }\r\n\r\n    private String register(User user, ClientRunnable client)  {\r\n        try {\r\n            if(user.getLogin().length() < 5 || user.getLogin().length() >20){\r\n                throw new RegistrationImpossibleException(\"Longeur du loggin incorrect (\"+user.getLogin().length()+\")\");\r\n            }\r\n            server.registerUser(user);\r\n            client.setUser(user);\r\n            return \"+OK\";\r\n        } catch (RegistrationImpossibleException e) {\r\n            return \"-ERR\";\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void close() {\r\n        this.executorService.shutdown();\r\n        try {\r\n            if (!this.executorService.awaitTermination(60, TimeUnit.SECONDS)) {\r\n                this.executorService.shutdownNow();\r\n            }\r\n        } catch (InterruptedException e) {\r\n            this.executorService.shutdownNow();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/system/Executor.java b/app/src/main/java/org/helmo/murmurG6/system/Executor.java
--- a/app/src/main/java/org/helmo/murmurG6/system/Executor.java	(revision 8b5f92cac09e374c468a18480daf87b01257c36b)
+++ b/app/src/main/java/org/helmo/murmurG6/system/Executor.java	(date 1676459202921)
@@ -4,6 +4,7 @@
 
 import java.util.concurrent.*;
 import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 public class Executor implements Runnable, AutoCloseable {
 
@@ -134,7 +135,7 @@
 
     private String register(User user, ClientRunnable client)  {
         try {
-            if(user.getLogin().length() < 5 || user.getLogin().length() >20){
+            if(!Pattern.matches(Protocol.RX_USERNAME, user.getLogin())){
                 throw new RegistrationImpossibleException("Longeur du loggin incorrect ("+user.getLogin().length()+")");
             }
             server.registerUser(user);
Index: app/src/main/java/org/helmo/murmurG6/models/Protocol.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.models;\r\n\r\nimport org.helmo.murmurG6.repository.IProtocol;\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class Protocol implements IProtocol {\r\n\r\n    /*\r\n     * ACSII Characters\r\n     * [\\x21-\\x2f] : correspond à la plage des codes hexadécimaux 0x21 à 0x2f, qui comprend les symboles suivants :\r\n     * ! \" # $ % & ' ( ) * + , - . /\r\n     *\r\n     * [\\x3a-\\x40] : correspond à la plage des codes hexadécimaux 0x3a à 0x40, qui comprend les symboles suivants :\r\n     * : ; < = > ? @\r\n     *\r\n     * [\\x5B-\\x60] : correspond à la plage des codes hexadécimaux 0x5B à 0x60, qui comprend les symboles suivants :\r\n     * [ \\ ] ^ _ `\r\n     *\r\n     */\r\n\r\n    private static final String RX_DIGIT = \"[0-9]\";\r\n    private static final String RX_LETTER = \"[a-zA-Z]\";\r\n    private static final String RX_LETTER_DIGIT = RX_LETTER + \"|\" + RX_DIGIT;\r\n    private static final String RX_SYMBOL = \"[\\\\x21-\\\\x2f]|[\\\\x3a-\\\\x40]|[\\\\x5B-\\\\x60]\";\r\n    private static final String RX_ROUND = \"(\" + RX_DIGIT + \"{2})\";\r\n    private static final String RX_PASSCHAR = \"[\\\\x22-\\\\xff]\";\r\n    private static final String RX_VISIBLE_CHARACTER = \"[\\\\x20-\\\\xff]\";\r\n    private static final String RX_INFORMATION_MESSAGE = \"((\" + RX_VISIBLE_CHARACTER + \"){0,200})\";\r\n    private static final String RX_RANDOM = \"((\" + RX_LETTER_DIGIT + \"|\" + RX_SYMBOL + \"){22})\";\r\n    private static final String RX_BCRYPT_SALT = \"((\" + RX_LETTER_DIGIT + \"|\" + RX_SYMBOL + \"){22})\";\r\n    private final static String RX_ESP = \"\\\\s\";\r\n    private static final String RX_DOMAIN = \"((\" + RX_LETTER_DIGIT + \"|\\\\.){5,200})\";\r\n    private static final String RX_USERNAME = \"((\" + RX_LETTER_DIGIT + \"){5,20})\";\r\n    private static final String RX_USER_DOMAIN = \"(\" + RX_USERNAME + \"@\" + RX_DOMAIN + \")\";\r\n    private static final String RX_MESSAGE = \"((\" + RX_VISIBLE_CHARACTER + \"){1,250})\";\r\n    private static final String RX_SHA3_EX = \"((\" + RX_LETTER_DIGIT+ \"){30,200})\";\r\n\r\n    /*PARTS*/\r\n    private static final String RX_CRLF = \"(\\\\x0d\\\\x0a){0,1}\";\r\n    private static final String RX_SALT_SIZE = \"([0-9]{2})\";\r\n    private static final String RX_BCRYPT_HASH = \"(\\\\$2b\\\\$\\\\d{2}\\\\$(\" + RX_LETTER_DIGIT + \"|\" + RX_SYMBOL + \"){1,70})\";\r\n    private static final String TAG = \"#[a-zA-Z0-9]{5,20}\";\r\n    private static final String TAG_DOMAIN = \"(\" + \"(\" + TAG + \")\" + \"@\" + RX_DOMAIN + \")\";\r\n\r\n    private static final String TAG_DOMAIN_OR_RX_USER_DOMAIN = \"(\" + RX_USER_DOMAIN + \"|\" + TAG_DOMAIN + \")\";\r\n\r\n\r\n    /*FULL*/\r\n    private final static String CONNECT = \"CONNECT\" + RX_ESP + RX_USERNAME + RX_CRLF;\r\n    private final static String REGISTER = \"REGISTER\" + RX_ESP + RX_USERNAME + RX_ESP + RX_SALT_SIZE + RX_ESP + RX_BCRYPT_HASH + RX_CRLF;\r\n    private final static String FOLLOW = \"FOLLOW\" + RX_ESP + TAG_DOMAIN_OR_RX_USER_DOMAIN + RX_CRLF;\r\n    private final static String CONFIRM = \"CONFIRM\" + RX_ESP + RX_SHA3_EX + RX_CRLF;\r\n    private final static String DISCONNECT = \"DISCONNECT\" + RX_CRLF;\r\n    private final static String MSG = \"MSG\" + RX_ESP + RX_MESSAGE;\r\n    private final String[] TYPE_MESSAGE = {CONNECT, REGISTER, FOLLOW, CONFIRM, DISCONNECT, MSG};\r\n\r\n    /**\r\n     * Méthode qui permet de créer une Objet Message sur base d'une string\r\n     * @param msg String qui est le message reçu depuis le Client\r\n     * @return Message(typeMessage, matcher, msg)\r\n     */\r\n    @Override\r\n    public Task analyseMessage(String msg){\r\n        for (int i = 0; i < TYPE_MESSAGE.length; i++) {\r\n            if(Pattern.matches(TYPE_MESSAGE[i], msg)){\r\n                return new Task(identifyTypeMessage(i), createMatcher(msg, i), msg);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Méthode qui permet d'identifier le type d'un message\r\n     * @param i i qui est l'index dans le tableau des différents types de message\r\n     * @return MessageType qui est le type de message\r\n     */\r\n    private TaskType identifyTypeMessage(int i){\r\n        switch (i){\r\n            case 0:\r\n                return TaskType.CONNECT;\r\n            case 1:\r\n                return TaskType.REGISTER;\r\n            case 2:\r\n                return TaskType.FOLLOW;\r\n            case 3:\r\n                return TaskType.CONFIRM;\r\n            case 4:\r\n                return TaskType.DISCONNECT;\r\n            case 5:\r\n                return TaskType.MSG;\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Méthode qui permet de créer un Matcher qui reprend les différentes parties d'un message\r\n     * @param msg String qui est le message reçu depuis le client\r\n     * @param i int qui est l'index dans le tableau des différents types de message\r\n     * @return Matcher qui comporte les différentes parties d'un message\r\n     */\r\n    private Matcher createMatcher(String msg, int i){\r\n        Pattern pattern = Pattern.compile(TYPE_MESSAGE[i]);\r\n        Matcher matcher = pattern.matcher(msg);\r\n        matcher.matches();\r\n        return matcher;\r\n    }\r\n\r\n    public static boolean isFollowUser(String msg){\r\n        return msg.charAt(0) != '#';\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/models/Protocol.java b/app/src/main/java/org/helmo/murmurG6/models/Protocol.java
--- a/app/src/main/java/org/helmo/murmurG6/models/Protocol.java	(revision 8b5f92cac09e374c468a18480daf87b01257c36b)
+++ b/app/src/main/java/org/helmo/murmurG6/models/Protocol.java	(date 1676459202939)
@@ -32,7 +32,7 @@
     private static final String RX_BCRYPT_SALT = "((" + RX_LETTER_DIGIT + "|" + RX_SYMBOL + "){22})";
     private final static String RX_ESP = "\\s";
     private static final String RX_DOMAIN = "((" + RX_LETTER_DIGIT + "|\\.){5,200})";
-    private static final String RX_USERNAME = "((" + RX_LETTER_DIGIT + "){5,20})";
+    public static final String RX_USERNAME = "((" + RX_LETTER_DIGIT + "){5,20})";
     private static final String RX_USER_DOMAIN = "(" + RX_USERNAME + "@" + RX_DOMAIN + ")";
     private static final String RX_MESSAGE = "((" + RX_VISIBLE_CHARACTER + "){1,250})";
     private static final String RX_SHA3_EX = "((" + RX_LETTER_DIGIT+ "){30,200})";
