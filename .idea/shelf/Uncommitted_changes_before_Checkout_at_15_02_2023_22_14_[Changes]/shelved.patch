Index: app/src/main/java/org/helmo/murmurG6/models/User.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.models;\r\n\r\nimport java.util.List;\r\n\r\npublic class User {\r\n\r\n    private final String login; //Login de l'utilisateur.\r\n    private final BCrypt bCrypt;\r\n    private final List<String> followedUsers; //Liste des utilisateurs suivis par l'utilisateur.\r\n    private final List<String> followedTrends; //Liste des tendances suivies par l'utilisateur.\r\n\r\n    public User(String login, BCrypt bCrypt, List<String> followedUsers, List<String> followedTrends) {\r\n        this.login = login;\r\n        this.bCrypt = bCrypt;\r\n        this.followedUsers = followedUsers;\r\n        this.followedTrends = followedTrends;\r\n    }\r\n\r\n    public BCrypt getBcrypt() { return this.bCrypt; }\r\n\r\n    public String getLogin() {\r\n        return this.login;\r\n    }\r\n\r\n    public String getBcryptHash() {\r\n        return this.bCrypt.getHash();\r\n    }\r\n\r\n    public int getBcryptRound() {\r\n        return this.bCrypt.getRounds();\r\n    }\r\n\r\n    public String getBcryptSalt() {\r\n        return this.bCrypt.getSalt();\r\n    }\r\n\r\n    /**\r\n     * Retourne la liste des utilisateurs suivis par l'utilisateur.\r\n     * @return liste des utilisateurs suivis par l'utilisateur.\r\n     */\r\n    public List<String> getFollowedUsers() {\r\n        return followedUsers;\r\n    }\r\n\r\n    /**\r\n     * Retourne la liste des trends suivies par l'utilisateur.\r\n     * @return liste des trends suivies par l'utilisateur.\r\n     */\r\n    public List<String> getFollowedTrends() {\r\n        return followedTrends;\r\n    }\r\n\r\n\r\n    /**\r\n     * Permet d'ajouter un utilisateur à sa liste d'abonnement\r\n     * @param userId L'id de l'utilisateur i.e : swila@server1.godswila.guru\r\n     */\r\n    public void followUser(String userId) {\r\n        if (!this.followedUsers.contains(userId)) {\r\n            this.followedUsers.add(userId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Permet d'ajouter une tendance à sa liste d'abonnement\r\n     * @param trendId L'id de l'utilisateur i.e : #tendance1234@server1.godswila.guru\r\n     */\r\n    public void followTrend(String trendId) {\r\n        if (!this.followedTrends.contains(trendId)) {\r\n            this.followedUsers.add(trendId);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/models/User.java b/app/src/main/java/org/helmo/murmurG6/models/User.java
--- a/app/src/main/java/org/helmo/murmurG6/models/User.java	(revision 66679d0a7245a4502b051ebc28b8afa77bb328da)
+++ b/app/src/main/java/org/helmo/murmurG6/models/User.java	(date 1676491479399)
@@ -16,7 +16,31 @@
         this.followedTrends = followedTrends;
     }
 
-    public BCrypt getBcrypt() { return this.bCrypt; }
+    /**
+     * Permet d'ajouter un utilisateur à sa liste d'abonnement
+     *
+     * @param userId L'id de l'utilisateur i.e : swila@server1.godswila.guru
+     */
+    public void followUser(String userId) {
+        if (!this.followedUsers.contains(userId)) {
+            this.followedUsers.add(userId);
+        }
+    }
+
+    /**
+     * Permet d'ajouter une tendance à sa liste d'abonnement
+     *
+     * @param trendId L'id de l'utilisateur i.e : #tendance1234@server1.godswila.guru
+     */
+    public void followTrend(String trendId) {
+        if (!this.followedTrends.contains(trendId)) {
+            this.followedUsers.add(trendId);
+        }
+    }
+
+    public BCrypt getBcrypt() {
+        return this.bCrypt;
+    }
 
     public String getLogin() {
         return this.login;
@@ -36,6 +60,7 @@
 
     /**
      * Retourne la liste des utilisateurs suivis par l'utilisateur.
+     *
      * @return liste des utilisateurs suivis par l'utilisateur.
      */
     public List<String> getFollowedUsers() {
@@ -44,30 +69,10 @@
 
     /**
      * Retourne la liste des trends suivies par l'utilisateur.
+     *
      * @return liste des trends suivies par l'utilisateur.
      */
     public List<String> getFollowedTrends() {
         return followedTrends;
     }
-
-
-    /**
-     * Permet d'ajouter un utilisateur à sa liste d'abonnement
-     * @param userId L'id de l'utilisateur i.e : swila@server1.godswila.guru
-     */
-    public void followUser(String userId) {
-        if (!this.followedUsers.contains(userId)) {
-            this.followedUsers.add(userId);
-        }
-    }
-
-    /**
-     * Permet d'ajouter une tendance à sa liste d'abonnement
-     * @param trendId L'id de l'utilisateur i.e : #tendance1234@server1.godswila.guru
-     */
-    public void followTrend(String trendId) {
-        if (!this.followedTrends.contains(trendId)) {
-            this.followedUsers.add(trendId);
-        }
-    }
 }
\ No newline at end of file
Index: app/src/main/java/org/helmo/murmurG6/models/BCrypt.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.models;\r\n\r\nimport java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\n\r\n/**\r\n * <p>La classe BcryptHash représente un hachage Bcrypt d'un mot de passe.</p><br>\r\n *\r\n * <p>Elle contient les informations sur le nombre de tours utilisé pour le hachage (rounds),\r\n * la valeur de sel utilisée (salt), et le hachage résultant (hash).</p><br>\r\n *\r\n * <p>Cette classe fournit également des méthodes pour décomposer un hachage Bcrypt en ses composants,\r\n * calculer le hachage d'une chaîne de caractères aléatoire et du hachage BCrypt,\r\n * et convertir un tableau d'octets en une chaîne de caractères hexadécimale.</p>\r\n *\r\n * @since 11 février 2023\r\n * @version 1.0\r\n */\r\npublic class BCrypt {\r\n\r\n    private final int rounds;\r\n    private final String salt;\r\n    private final String hash;\r\n\r\n    public BCrypt(int rounds, String salt, String hash) {\r\n        this.rounds = rounds;\r\n        this.salt = salt;\r\n        this.hash = hash;\r\n    }\r\n\r\n    public int getRounds() {\r\n        return rounds;\r\n    }\r\n\r\n    public String getSalt() {\r\n        return salt;\r\n    }\r\n\r\n    public String getHash() {\r\n        return hash;\r\n    }\r\n\r\n\r\n    /**\r\n     * Construit un Bcrypt\r\n     *\r\n     * @param hashed le hachage Bcrypt à décomposer, qui doit avoir le format suivant : $2a$RR$SALT$HASH\r\n     * où RR représente le nombre de tours de l'algorithme de hachage, SALT est la valeur de sel utilisée\r\n     * lors du hachage et HASH est le hachage résultant.\r\n     *\r\n     * @return un objet BcryptHash contenant les informations décomposées : le nombre de tours (rounds), la valeur de sel (salt)\r\n     * et le hachage (hash).\r\n     */\r\n    public static BCrypt of(String hashed) {\r\n        //TODO\r\n        //try catch regex\r\n        int rounds = Integer.parseInt(hashed.substring(4, 6));\r\n        String salt = hashed.substring(7, 29);\r\n        String hash = hashed.substring(29);\r\n        return new BCrypt(rounds, salt, hash);\r\n    }\r\n\r\n    /**\r\n     * La méthode calculateChallenge calcule le hachage de la chaîne de caractères aléatoires et du hachage BCrypt en utilisant l'algorithme SHA3-256.\r\n     * Le hachage BCrypt inclut le nombre de tours et le sel associé au mot de passe.\r\n     * Le résultat de la fonction de hachage est retourné sous forme hexadécimale.\r\n     *\r\n     * @param random La chaîne de caractères aléatoires reçue lors de la connexion avec le serveur.\r\n     * @return Le hachage calculé sous forme hexadécimale.\r\n     */\r\n    public String generateChallenge(String random) {\r\n        try {\r\n            MessageDigest md = MessageDigest.getInstance(\"SHA3-256\");\r\n            byte[] unHashedChallengeBytes = (random + this.toString()).getBytes();\r\n            byte[] hashedBytes = md.digest(unHashedChallengeBytes);\r\n            return bytesToHex(hashedBytes);\r\n        } catch (NoSuchAlgorithmException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Cette méthode permet de convertir un tableau d'octets en une chaîne de caractères hexadécimale.\r\n     *\r\n     * @param bytes Le tableau d'octets à convertir.\r\n     * @return La chaîne de caractères hexadécimale représentant le tableau d'octets.\r\n     */\r\n    private String bytesToHex(byte[] bytes) {\r\n        StringBuilder sb = new StringBuilder(bytes.length * 2);\r\n        for (byte b : bytes) {\r\n            sb.append(String.format(\"%02x\", b & 0xff));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"$2b$\"+ this.rounds + \"$\" + this.salt + this.hash;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/models/BCrypt.java b/app/src/main/java/org/helmo/murmurG6/models/BCrypt.java
--- a/app/src/main/java/org/helmo/murmurG6/models/BCrypt.java	(revision 66679d0a7245a4502b051ebc28b8afa77bb328da)
+++ b/app/src/main/java/org/helmo/murmurG6/models/BCrypt.java	(date 1676491093521)
@@ -2,6 +2,7 @@
 
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.regex.Pattern;
 
 /**
  * <p>La classe BcryptHash représente un hachage Bcrypt d'un mot de passe.</p><br>
@@ -28,56 +29,33 @@
         this.hash = hash;
     }
 
-    public int getRounds() {
-        return rounds;
-    }
-
-    public String getSalt() {
-        return salt;
-    }
-
-    public String getHash() {
-        return hash;
-    }
-
-
-    /**
-     * Construit un Bcrypt
-     *
-     * @param hashed le hachage Bcrypt à décomposer, qui doit avoir le format suivant : $2a$RR$SALT$HASH
-     * où RR représente le nombre de tours de l'algorithme de hachage, SALT est la valeur de sel utilisée
-     * lors du hachage et HASH est le hachage résultant.
-     *
-     * @return un objet BcryptHash contenant les informations décomposées : le nombre de tours (rounds), la valeur de sel (salt)
-     * et le hachage (hash).
-     */
     public static BCrypt of(String hashed) {
-        //TODO
-        //try catch regex
+        if (!Pattern.matches(Protocol.RX_BCRYPT_HASH, hashed)) {
+            throw new IllegalArgumentException("Le hash bcrypt fourni n'est pas au format attendu. Veuillez vérifier que le hash est une chaîne valide conforme au format bcrypt.");
+        }
+
         int rounds = Integer.parseInt(hashed.substring(4, 6));
         String salt = hashed.substring(7, 29);
         String hash = hashed.substring(29);
+
         return new BCrypt(rounds, salt, hash);
     }
 
-    /**
-     * La méthode calculateChallenge calcule le hachage de la chaîne de caractères aléatoires et du hachage BCrypt en utilisant l'algorithme SHA3-256.
-     * Le hachage BCrypt inclut le nombre de tours et le sel associé au mot de passe.
-     * Le résultat de la fonction de hachage est retourné sous forme hexadécimale.
-     *
-     * @param random La chaîne de caractères aléatoires reçue lors de la connexion avec le serveur.
-     * @return Le hachage calculé sous forme hexadécimale.
-     */
+
     public String generateChallenge(String random) {
+        MessageDigest md;
         try {
-            MessageDigest md = MessageDigest.getInstance("SHA3-256");
-            byte[] unHashedChallengeBytes = (random + this.toString()).getBytes();
-            byte[] hashedBytes = md.digest(unHashedChallengeBytes);
-            return bytesToHex(hashedBytes);
-        } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException(e);
-        }
+            md = MessageDigest.getInstance("SHA3-256");
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException("Impossible de générer un challenge. L'algorithme de hachage SHA3-256 n'est pas disponible.", e);
+        }
+
+        byte[] unHashedChallengeBytes = (random + this).getBytes();
+        byte[] hashedBytes = md.digest(unHashedChallengeBytes);
+
+        return bytesToHex(hashedBytes);
     }
+
 
 
     /**
@@ -87,13 +65,25 @@
      * @return La chaîne de caractères hexadécimale représentant le tableau d'octets.
      */
     private String bytesToHex(byte[] bytes) {
-        StringBuilder sb = new StringBuilder(bytes.length * 2);
+        StringBuilder sb = new StringBuilder();
         for (byte b : bytes) {
-            sb.append(String.format("%02x", b & 0xff));
+            sb.append(String.format("%02x", b));
         }
         return sb.toString();
     }
 
+    public int getRounds() {
+        return rounds;
+    }
+
+    public String getSalt() {
+        return salt;
+    }
+
+    public String getHash() {
+        return hash;
+    }
+
     @Override
     public String toString() {
         return "$2b$"+ this.rounds + "$" + this.salt + this.hash;
Index: app/src/main/java/org/helmo/murmurG6/infrastructure/UserJsonStorage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.infrastructure;\r\n\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.reflect.TypeToken;\r\nimport org.helmo.murmurG6.infrastructure.dto.Mapper;\r\nimport org.helmo.murmurG6.infrastructure.dto.UserDto;\r\nimport org.helmo.murmurG6.models.User;\r\nimport org.helmo.murmurG6.models.UserLibrary;\r\nimport org.helmo.murmurG6.repository.UserRepository;\r\nimport org.helmo.murmurG6.repository.exceptions.ReadUserCollectionException;\r\nimport org.helmo.murmurG6.repository.exceptions.SaveUserCollectionException;\r\nimport java.io.*;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\nimport java.nio.file.StandardOpenOption;\r\nimport java.util.*;\r\n\r\n/**\r\n * Cette classe implémente l'interface {@link UserRepository} et permet de sauvegarder et de lire des collections d'utilisateurs sous forme de fichier JSON.\r\n * La classe utilise la bibliothèque Google Gson pour effectuer les opérations de conversion entre les objets Java et les données JSON.\r\n * Les fichiers sont sauvegardés dans un emplacement spécifié par la classe {@link JsonConfig}.\r\n *\r\n * @since 11 février 2023\r\n * @version 1.0\r\n */\r\npublic class UserJsonStorage implements UserRepository{\r\n    private final Path FILE_PATH = Paths.get(JsonConfig.SAVE_DIR, \"/user.json\");\r\n    private final Gson gson = new Gson();\r\n\r\n\r\n\r\n    /**\r\n     * Cette méthode sauvegarde une collection d'utilisateurs en tant que fichier JSON à l'emplacement spécifié.\r\n     * Si le fichier n'existe pas, il sera créé.\r\n     * @param uc\r\n     * @throws SaveUserCollectionException\r\n     */\r\n    @Override\r\n    public void save(Map uc) throws SaveUserCollectionException {\r\n        createFile(FILE_PATH);\r\n\r\n        try(BufferedWriter bufferedWriter = Files.newBufferedWriter(FILE_PATH, StandardCharsets.UTF_8, StandardOpenOption.CREATE)){\r\n            gson.toJson(Mapper.userDtoListFromUsers(new ArrayList<>(uc.values())), new TypeToken<ArrayList<UserDto>>(){}.getType(), bufferedWriter);\r\n        }catch(IOException e){\r\n            throw new SaveUserCollectionException(\"Impossible de sauvegarder la liste d'utilisateur!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     * Cette méthode lit une collection d'utilisateurs enregistrée en tant que fichier JSON à l'emplacement spécifié.\r\n     * Si le fichier n'existe pas, il sera créé.\r\n     */\r\n    @Override\r\n    public UserLibrary load() throws ReadUserCollectionException {\r\n        createFile(FILE_PATH);\r\n\r\n        try (BufferedReader reader = Files.newBufferedReader(FILE_PATH, StandardCharsets.UTF_8)) {\r\n            Iterable<UserDto> resultDto = gson.fromJson(reader, new TypeToken<ArrayList<UserDto>>(){}.getType());\r\n            return UserLibrary.of(Mapper.userListFromDto(resultDto));\r\n        } catch (IOException e) {\r\n            throw new ReadUserCollectionException(\"Impossible de charger la liste d'utilisateurs!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Crée un fichier à l'emplacement spécifié. Si le répertoire parent de l'emplacement n'existe pas, il sera créé.\r\n     * @param path l'emplacement du fichier à créer\r\n     */\r\n    private void createFile(Path path) {\r\n        try {\r\n            Files.createDirectories(path.getParent());\r\n            if (!Files.exists(path)) {\r\n                Files.createFile(path);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/infrastructure/UserJsonStorage.java b/app/src/main/java/org/helmo/murmurG6/infrastructure/UserJsonStorage.java
--- a/app/src/main/java/org/helmo/murmurG6/infrastructure/UserJsonStorage.java	(revision 66679d0a7245a4502b051ebc28b8afa77bb328da)
+++ b/app/src/main/java/org/helmo/murmurG6/infrastructure/UserJsonStorage.java	(date 1676491479405)
@@ -4,7 +4,6 @@
 import com.google.gson.reflect.TypeToken;
 import org.helmo.murmurG6.infrastructure.dto.Mapper;
 import org.helmo.murmurG6.infrastructure.dto.UserDto;
-import org.helmo.murmurG6.models.User;
 import org.helmo.murmurG6.models.UserLibrary;
 import org.helmo.murmurG6.repository.UserRepository;
 import org.helmo.murmurG6.repository.exceptions.ReadUserCollectionException;
Index: app/src/main/java/org/helmo/murmurG6/models/Protocol.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.helmo.murmurG6.models;\r\n\r\nimport java.util.Map;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class Protocol {\r\n\r\n    /*\r\n     * ACSII Characters\r\n     * [\\x21-\\x2f] : correspond à la plage des codes hexadécimaux 0x21 à 0x2f, qui comprend les symboles suivants :\r\n     * ! \" # $ % & ' ( ) * + , - . /\r\n     *\r\n     * [\\x3a-\\x40] : correspond à la plage des codes hexadécimaux 0x3a à 0x40, qui comprend les symboles suivants :\r\n     * : ; < = > ? @\r\n     *\r\n     * [\\x5B-\\x60] : correspond à la plage des codes hexadécimaux 0x5B à 0x60, qui comprend les symboles suivants :\r\n     * [ \\ ] ^ _ `\r\n     *\r\n     */\r\n\r\n    private static final String RX_DIGIT = \"[0-9]\";\r\n    private static final String RX_LETTER = \"[a-zA-Z]\";\r\n    private static final String RX_LETTER_DIGIT = RX_LETTER + \"|\" + RX_DIGIT;\r\n    private static final String RX_SYMBOL = \"[\\\\x21-\\\\x2f]|[\\\\x3a-\\\\x40]|[\\\\x5B-\\\\x60]\";\r\n    private static final String RX_ROUND = \"(\" + RX_DIGIT + \"{2})\";\r\n    private static final String RX_PASSCHAR = \"[\\\\x22-\\\\xff]\";\r\n    private static final String RX_VISIBLE_CHARACTER = \"[\\\\x20-\\\\xff]\";\r\n    private static final String RX_INFORMATION_MESSAGE = \"((\" + RX_VISIBLE_CHARACTER + \"){0,200})\";\r\n    private static final String RX_RANDOM = \"((\" + RX_LETTER_DIGIT + \"|\" + RX_SYMBOL + \"){22})\";\r\n    private static final String RX_BCRYPT_SALT = \"((\" + RX_LETTER_DIGIT + \"|\" + RX_SYMBOL + \"){22})\";\r\n    private final static String RX_ESP = \"\\\\s\";\r\n    private static final String RX_DOMAIN = \"((\" + RX_LETTER_DIGIT + \"|\\\\.){5,200})\";\r\n    private static final String RX_USERNAME = \"((\" + RX_LETTER_DIGIT + \"){5,20})\";\r\n    private static final String RX_USER_DOMAIN = \"(\" + RX_USERNAME + \"@\" + RX_DOMAIN + \")\";\r\n    private static final String RX_MESSAGE = \"((\" + RX_VISIBLE_CHARACTER + \"){1,250})\";\r\n    private static final String RX_SHA3_EX = \"((\" + RX_LETTER_DIGIT + \"){30,200})\";\r\n\r\n    /*PARTS*/\r\n    private static final String RX_CRLF = \"(\\\\x0d\\\\x0a){0,1}\";\r\n    private static final String RX_SALT_SIZE = \"([0-9]{2})\";\r\n    private static final String RX_BCRYPT_HASH = \"(\\\\$2b\\\\$\\\\d{2}\\\\$(\" + RX_LETTER_DIGIT + \"|\" + RX_SYMBOL + \"){1,70})\";\r\n    private static final String TAG = \"#[a-zA-Z0-9]{5,20}\";\r\n    private static final String TAG_DOMAIN = \"(\" + TAG + \"@\" + RX_DOMAIN + \")\";\r\n\r\n    private static final String TAG_DOMAIN_OR_RX_USER_DOMAIN = \"(\" + RX_USER_DOMAIN + \"|\" + TAG_DOMAIN + \")\";\r\n\r\n\r\n    /*FULL*/\r\n    private final static Pattern RX_CONNECT_TASK = Pattern.compile(\"CONNECT\" + RX_ESP + \"(?<username>\" + RX_USERNAME + \")\" + RX_CRLF);\r\n    private final static Pattern RX_REGISTER_TASK = Pattern.compile(\"REGISTER\" + RX_ESP + \"(?<username>\" + RX_USERNAME + \")\" + RX_ESP + RX_SALT_SIZE + RX_ESP + \"(?<bcrypt>\" + RX_BCRYPT_HASH + \")\" + RX_CRLF);\r\n    private final static Pattern RX_FOLLOW_TASK = Pattern.compile(\"FOLLOW\" + RX_ESP + \"(?<domain>\" + TAG_DOMAIN_OR_RX_USER_DOMAIN + \")\" + RX_CRLF);\r\n    private final static Pattern RX_CONFIRM_TASK = Pattern.compile(\"CONFIRM\" + RX_ESP + \"(?<challenge>\" + RX_SHA3_EX + \")\" + RX_CRLF);\r\n    private final static Pattern RX_DISCONNECT_TASK = Pattern.compile(\"DISCONNECT\" + RX_CRLF);\r\n    private final static Pattern RX_MSG_TASK = Pattern.compile(\"MSG\" + RX_ESP + \"(?<message>\" + RX_MESSAGE + \")\" + RX_CRLF);\r\n\r\n    private static final Map<Pattern, TaskType> TYPE_MESSAGE_MAP = Map.of(\r\n            RX_CONNECT_TASK, TaskType.CONNECT,\r\n            RX_REGISTER_TASK, TaskType.REGISTER,\r\n            RX_FOLLOW_TASK, TaskType.FOLLOW,\r\n            RX_CONFIRM_TASK, TaskType.CONFIRM,\r\n            RX_DISCONNECT_TASK, TaskType.DISCONNECT,\r\n            RX_MSG_TASK, TaskType.MSG\r\n    );\r\n\r\n    public static Task buildTask(String command) throws InvalidTaskException {\r\n        for (Map.Entry<Pattern, TaskType> entry : TYPE_MESSAGE_MAP.entrySet()) {\r\n            Matcher matcher = entry.getKey().matcher(command);\r\n            if (matcher.matches()) {\r\n                return new Task(entry.getValue(), matcher);\r\n            }\r\n        }\r\n        throw new InvalidTaskException(\"Tache invalide!\");\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/org/helmo/murmurG6/models/Protocol.java b/app/src/main/java/org/helmo/murmurG6/models/Protocol.java
--- a/app/src/main/java/org/helmo/murmurG6/models/Protocol.java	(revision 66679d0a7245a4502b051ebc28b8afa77bb328da)
+++ b/app/src/main/java/org/helmo/murmurG6/models/Protocol.java	(date 1676490642639)
@@ -39,7 +39,7 @@
     /*PARTS*/
     private static final String RX_CRLF = "(\\x0d\\x0a){0,1}";
     private static final String RX_SALT_SIZE = "([0-9]{2})";
-    private static final String RX_BCRYPT_HASH = "(\\$2b\\$\\d{2}\\$(" + RX_LETTER_DIGIT + "|" + RX_SYMBOL + "){1,70})";
+    public static final String RX_BCRYPT_HASH = "(\\$2b\\$\\d{2}\\$(" + RX_LETTER_DIGIT + "|" + RX_SYMBOL + "){1,70})";
     private static final String TAG = "#[a-zA-Z0-9]{5,20}";
     private static final String TAG_DOMAIN = "(" + TAG + "@" + RX_DOMAIN + ")";
 
